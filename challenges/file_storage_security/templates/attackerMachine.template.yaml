AWSTemplateFormatVersion: 2010-09-09
Description:
  tdc-2022-techday-1 Cloud One Container Security - Runs state machine to deploy
  nginx to EKS

Metadata:
  # cfn_lint: Disable warning for unused parameters
  cfn-lint:
    config:
      ignore_checks:
        - "W2001"

Parameters:
  QSS3BucketName:
    AllowedPattern: ^[0-9a-zA-Z]+([0-9a-zA-Z-]*[0-9a-zA-Z])*$
    ConstraintDescription:
      Quick Start bucket name can include numbers, lowercase letters, uppercase
      letters, and hyphens (-). It cannot start or end with a hyphen (-).
    Default: none
    Description:
      Update to where you hold the scripts. S3 bucket name for the Tech Day
      assets. Quick Start bucket name can include numbers, lowercase letters,
      uppercase letters, and hyphens (-). It cannot start or end with a hyphen
      (-).
    Type: String
  QSS3KeyPrefix:
    AllowedPattern: ^[0-9a-zA-Z-/._]*$
    ConstraintDescription:
      Quick Start key prefix can include numbers, lowercase letters, uppercase
      letters, hyphens (-), and forward slash (/).
    # REFERENCE (tdc-2022-2): Value in this file ↓
    Default: "latest/challenges/file_storage_security/templates"
    Description:
      Update to where you hold the scripts. S3 bucket name for the Tech Day
      assets. Quick Start key prefix can include numbers, lowercase letters,
      uppercase letters, hyphens (-), and forward slash (/).
    Type: String
  ToolsPrefix:
    AllowedPattern: ^[0-9a-zA-Z-/._]*$
    ConstraintDescription:
      Quick Start key prefix can include numbers, lowercase letters, uppercase
      letters, hyphens (-), and forward slash (/).
    # REFERENCE (tdc-2022-2): Value in this file ↓
    Default: "latest/challenges/file_storage_security/tools"
    Description:
      Update to where you hold the tools for this challenge. Quick Start key
      prefix can include numbers, lowercase letters, uppercase letters, hyphens
      (-), and forward slash (/).
    Type: String
  PlayerPassword:
    Description: The Player's password
    Type: String

Resources:
  # Create iAM Roles
  KubeCtlOperationsRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: "/"
      Policies:
        - PolicyName: KubeCtlOperationsRole
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - ssm:SendCommand
                  - ssm:PutParameter
                Resource:
                  - arn:aws:ssm:*:*:document/AWS-RunShellScript
                  - arn:aws:ssm:*:*:parameter/player/FSS/AttackerLBHostname
              - Effect: Allow
                Action:
                  - ssm:SendCommand
                Resource:
                  - arn:aws:ec2:*:*:instance/*
                Condition:
                  StringLike:
                    ssm:resourceTag/Name:
                      - EKSBastion
              - Effect: Allow
                Action:
                  - ssm:ListCommandInvocations
                Resource:
                  - arn:aws:ssm:*:*:*

  StateMachineDeployRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - states.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: "/service-role/"
      Policies:
        - PolicyName: StateMachinePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !GetAtt DeleteAttackerLBServiceLambda.Arn
                  - !GetAtt DeleteAttackerMachineDeploymentLambda.Arn
                  - !GetAtt DeleteAttackerNamespaceLambda.Arn
                  - !GetAtt CreateAttackerNamespaceLambda.Arn
                  - !GetAtt CreateAttackerMachineDeploymentLambda.Arn
                  - !GetAtt CreateAttackerLBServiceLambda.Arn
                  - !GetAtt InstallToolsLambda.Arn
                  - !GetAtt UserModsLambda.Arn
                  - !GetAtt GetAttackerLBHostnameLambda.Arn

  # SSM Parameters
  StateMachineDeployArn:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /player/C1CS/StateMachineDeployArn
      Type: String
      Value: !Ref StateMachineDeploy
      Description: ARN for StateMachineDeploy state machine
  AttackerLBHostname:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /player/FSS/AttackerLBHostname
      Type: String
      Value: startingValue
      Description: Load Balancer Hostname for nginx web server

  # Lambda functions
  DeleteAttackerLBServiceLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.8
      Timeout: 20
      Handler: index.lambda_handler
      Role: !GetAtt KubeCtlOperationsRole.Arn
      Code:
        ZipFile: !Sub |
          import boto3


          def lambda_handler(event=None, context=None):
              client = boto3.client("ssm")
              client.send_command(
                  Targets=[{"Key": "tag:Name", "Values": ["EKSBastion"]}],
                  DocumentName="AWS-RunShellScript",
                  Parameters={
                      "commands": [
                          # curls QSS3Bucket for manifest and deletes it
                          "curl https://${QSS3BucketName}.s3.amazonaws.com/${QSS3KeyPrefix}k8s/attacker-loadbalancer-service.yaml | sudo /usr/local/bin/kubectl delete --namespace=$(echo ${AWS::StackName} | tr '[:upper:]' '[:lower:]') --ignore-not-found=true -f -"
                      ]
                  },
                  )
  DeleteAttackerMachineDeploymentLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.8
      Timeout: 20
      Handler: index.lambda_handler
      Role: !GetAtt KubeCtlOperationsRole.Arn
      Code:
        ZipFile: !Sub |
          import boto3


          def lambda_handler(event=None, context=None):
              client = boto3.client("ssm")
              client.send_command(
                  Targets=[{"Key": "tag:Name", "Values": ["EKSBastion"]}],
                  DocumentName="AWS-RunShellScript",
                  Parameters={
                      "commands": [
                          # curls QSS3Bucket for manifest and deletes it
                          "curl https://${QSS3BucketName}.s3.amazonaws.com/${QSS3KeyPrefix}k8s/attacker-machine-deployment.yaml | sudo /usr/local/bin/kubectl delete --namespace=$(echo ${AWS::StackName} | tr '[:upper:]' '[:lower:]') --ignore-not-found=true -f -"
                      ]
                  },
              )
  DeleteAttackerNamespaceLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.8
      Timeout: 20
      Handler: index.lambda_handler
      Role: !GetAtt KubeCtlOperationsRole.Arn
      Code:
        ZipFile: !Sub |
          import boto3


          def lambda_handler(event=None, context=None):
              client = boto3.client("ssm")
              client.send_command(
                  Targets=[{"Key": "tag:Name", "Values": ["EKSBastion"]}],
                  DocumentName="AWS-RunShellScript",
                  Parameters={
                      "commands": [
                          "sudo /usr/local/bin/kubectl delete namespace $(echo ${AWS::StackName} | tr '[:upper:]' '[:lower:]') --ignore-not-found=true"
                      ]
                  },
              )
  CreateAttackerNamespaceLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.8
      Timeout: 20
      Handler: index.lambda_handler
      Role: !GetAtt KubeCtlOperationsRole.Arn
      Code:
        ZipFile: !Sub |
          import boto3


          def lambda_handler(event=None, context=None):
              client = boto3.client("ssm")
              client.send_command(
                  Targets=[{"Key": "tag:Name", "Values": ["EKSBastion"]}],
                  DocumentName="AWS-RunShellScript",
                  Parameters={
                      "commands": [
                          "sudo /usr/local/bin/kubectl create namespace $(echo ${AWS::StackName} | tr '[:upper:]' '[:lower:]')"
                      ]
                  },
              )
  CreateAttackerMachineDeploymentLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.8
      Timeout: 20
      Handler: index.lambda_handler
      Role: !GetAtt KubeCtlOperationsRole.Arn
      Code:
        ZipFile: !Sub |
          import boto3


          def lambda_handler(event=None, context=None):
              client = boto3.client("ssm")
              client.send_command(
                  Targets=[{"Key": "tag:Name", "Values": ["EKSBastion"]}],
                  DocumentName="AWS-RunShellScript",
                  Parameters={
                      "commands": [
                          # curls QSS3Bucket for manifest and applies it
                          "curl https://${QSS3BucketName}.s3.amazonaws.com/${QSS3KeyPrefix}k8s/attacker-machine-deployment.yaml | sudo /usr/local/bin/kubectl apply --namespace=$(echo ${AWS::StackName} | tr '[:upper:]' '[:lower:]') -f -"
                      ]
                  },
              )
  CreateAttackerLBServiceLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.8
      Timeout: 20
      Handler: index.lambda_handler
      Role: !GetAtt KubeCtlOperationsRole.Arn
      Code:
        ZipFile: !Sub |
          import boto3


          def lambda_handler(event=None, context=None):
              client = boto3.client("ssm")
              client.send_command(
                  Targets=[{"Key": "tag:Name", "Values": ["EKSBastion"]}],
                  DocumentName="AWS-RunShellScript",
                  Parameters={
                      "commands": [
                          # curls QSS3Bucket for manifest and applies it
                          "curl https://${QSS3BucketName}.s3.amazonaws.com/${QSS3KeyPrefix}k8s/attacker-loadbalancer-service.yaml | sudo /usr/local/bin/kubectl apply --namespace=$(echo ${AWS::StackName} | tr '[:upper:]' '[:lower:]') -f -"
                      ]
                  },
              )
  InstallToolsLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.8
      Timeout: 20
      Handler: index.lambda_handler
      Role: !GetAtt KubeCtlOperationsRole.Arn
      Code:
        ZipFile: !Sub |
          import boto3


          def lambda_handler(event=None, context=None):
              client = boto3.client("ssm")
              client.send_command(
                  Targets=[{"Key": "tag:Name", "Values": ["EKSBastion"]}],
                  DocumentName="AWS-RunShellScript",
                  Parameters={
                      "commands": [
                          """sudo /usr/local/bin/kubectl get pods \\
                          --namespace=$(echo ${AWS::StackName} | tr '[:upper:]' '[:lower:]') \\
                          -l app=attacker-machine \\
                          -o jsonpath=\'{range .items[*]}{.status.containerStatuses[*].ready.true}{.metadata.name}{"\\n"}{end}\' | \\
                          xargs -I{} sudo /usr/local/bin/kubectl exec --namespace=$(echo ${AWS::StackName} | tr '[:upper:]' '[:lower:]') {} -- /bin/bash -c \\
                          \"sudo apt-get update && \\\\
                          sudo apt-get install -y vim openjdk-8-jdk curl unzip && \\\\
                          curl https://${QSS3BucketName}.s3.amazonaws.com/${ToolsPrefix}JNDIExploit-v1.2.zip --output /tmp/JNDIExploit-v1.2.zip && \\\\
                          sudo unzip -P novirus /tmp/JNDIExploit-v1.2.zip && \\\\
                          rm /tmp/JNDIExploit-v1.2.zip\""""
                      ]
                  },
              )
  UserModsLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.8
      Timeout: 20
      Handler: index.lambda_handler
      Role: !GetAtt KubeCtlOperationsRole.Arn
      Code:
        ZipFile: !Sub |
          import boto3


          def lambda_handler(event=None, context=None):
              client = boto3.client("ssm")
              client.send_command(
                  Targets=[{"Key": "tag:Name", "Values": ["EKSBastion"]}],
                  DocumentName="AWS-RunShellScript",
                  Parameters={
                      "commands": [
                          """sudo /usr/local/bin/kubectl get pods \\
                          --namespace=$(echo ${AWS::StackName} | tr '[:upper:]' '[:lower:]') \\
                          -l app=attacker-machine \\
                          -o jsonpath=\'{range .items[*]}{.status.containerStatuses[*].ready.true}{.metadata.name}{"\\n"}{end}\' | \\
                          xargs -I{} sudo /usr/local/bin/kubectl exec --namespace=$(echo ${AWS::StackName} | tr '[:upper:]' '[:lower:]') {} -- /bin/bash -c \\
                          \"echo 'abc:${PlayerPassword}' | chpasswd && usermod -l Player abc\""""
                      ]
                  },
              )
  GetAttackerLBHostnameLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.8
      Timeout: 20
      Handler: index.lambda_handler
      Role: !GetAtt KubeCtlOperationsRole.Arn
      Code:
        ZipFile: !Sub |
          import json
          import boto3
          import botocore
          import time


          def lambda_handler(event=None, context=None):
              client = boto3.client("ssm")
              response = client.send_command(
                  Targets=[{"Key": "tag:Name", "Values": ["EKSBastion"]}],
                  DocumentName="AWS-RunShellScript",
                  Parameters={
                      "commands": [
                          "sudo /usr/local/bin/kubectl get services --namespace $(echo ${AWS::StackName} | tr '[:upper:]' '[:lower:]') attacker-machine-loadbalancer --output jsonpath='{.status.loadBalancer.ingress[0].hostname}'"
                      ]
                  },
              )
              command_id = response["Command"]["CommandId"]
              tries = 0
              output = "False"
              while tries < 10:
                  tries = tries + 1
                  try:
                      time.sleep(0.5)  # some delay always required...
                      invocations_list = client.list_command_invocations(
                          CommandId=command_id,
                      ).CommandInvocations
                      result = sorted(
                          invocations_list, key=lambda d: d["RequestedDateTime"], reverse=True
                      )[0]
                      if result["Status"] == "InProgress":
                          continue
                      output = result["StandardOutputContent"]
                      break
                  except client.exceptions.InvocationDoesNotExist:
                      continue

              client.put_parameter(
                  Name="/player/FSS/AttackerLBHostname",
                  Value=output,
                  Type="String",
                  Overwrite=True,
              )

  # State Machine
  StateMachineDeploy:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: StateMachineDeploy
      DefinitionString: !Sub |
        {
          "StartAt": "DeleteAttackerLBServiceLambda",
          "States": {
            "DeleteAttackerLBServiceLambda": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "Payload.$": "$",
                "FunctionName": "${DeleteAttackerLBServiceLambda.Arn}"
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 6,
                  "BackoffRate": 2
                }
              ],
              "Next": "DeleteAttackerMachineDeploymentLambda"
            },
            "DeleteAttackerMachineDeploymentLambda": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "Payload.$": "$",
                "FunctionName": "${DeleteAttackerMachineDeploymentLambda.Arn}"
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 6,
                  "BackoffRate": 2
                }
              ],
              "Next": "DeleteAttackerNamespaceLambda"
            },
            "DeleteAttackerNamespaceLambda": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "Payload.$": "$",
                "FunctionName": "${DeleteAttackerNamespaceLambda.Arn}"
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 6,
                  "BackoffRate": 2
                }
              ],
              "Next": "CreateAttackerNamespaceLambda"
            },
            "CreateAttackerNamespaceLambda": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "Payload.$": "$",
                "FunctionName": "${CreateAttackerNamespaceLambda.Arn}"
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 6,
                  "BackoffRate": 2
                }
              ],
              "Next": "CreateAttackerMachineDeploymentLambda"
            },
            "CreateAttackerMachineDeploymentLambda": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "Payload.$": "$",
                "FunctionName": "${CreateAttackerMachineDeploymentLambda.Arn}"
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 6,
                  "BackoffRate": 2
                }
              ],
              "Next": "CreateAttackerLBServiceLambda"
            },
            "CreateAttackerLBServiceLambda": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "Payload.$": "$",
                "FunctionName": "${CreateAttackerLBServiceLambda.Arn}"
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 6,
                  "BackoffRate": 2
                }
              ],
              "Next": "Wait"
            },
            "Wait": {
              "Type": "Wait",
              "Seconds": 10,
              "Next": "InstallToolsLambda"
            },
            "InstallToolsLambda": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "Payload.$": "$",
                "FunctionName": "${InstallToolsLambda.Arn}"
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 6,
                  "BackoffRate": 2
                }
              ],
              "Next": "UserModsLambda"
            },
            "UserModsLambda": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "Payload.$": "$",
                "FunctionName": "${UserModsLambda.Arn}"
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 6,
                  "BackoffRate": 2
                }
              ],
              "Next": "GetAttackerLBHostnameLambda"
            },
            "GetAttackerLBHostnameLambda": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "Payload.$": "$",
                "FunctionName": "${GetAttackerLBHostnameLambda.Arn}"
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 6,
                  "BackoffRate": 2
                }
              ],
              "End": true
            }
          },
          "Comment": "Idempotent state machine that deploys an attacker environment to EKS through an EKS bastion.\nNOTE: The EKS bastion(s) in question must have be tagged: \"Name:EKSBastion\"."
        }
      RoleArn: !GetAtt [StateMachineDeployRole, Arn]

Outputs:
  DeleteAttackerLBServiceLambda:
    Description: Query Api Key role ARN
    Value: !GetAtt DeleteAttackerLBServiceLambda.Arn
  DeleteAttackerMachineDeploymentLambda:
    Description: Query Api Key role ARN
    Value: !GetAtt DeleteAttackerMachineDeploymentLambda.Arn
  CreateAttackerMachineDeploymentLambda:
    Description: Query Api Key role ARN
    Value: !GetAtt CreateAttackerMachineDeploymentLambda.Arn
  CreateAttackerLBServiceLambda:
    Description: Query Api Key role ARN
    Value: !GetAtt CreateAttackerLBServiceLambda.Arn
  InstallToolsLambda:
    Description: InstallToolsLambda Arn
    Value: !GetAtt InstallToolsLambda.Arn
  UserModsLambda:
    Description: UserModsLambda Arn
    Value: !GetAtt UserModsLambda.Arn
  GetAttackerLBHostnameLambda:
    Description: GetAttackerLBHostnameLambda Arn
    Value: !GetAtt GetAttackerLBHostnameLambda.Arn
  StateMachineDeploy:
    Description: State Machine that deploys the attacker environment in EKS
    Value: !GetAtt StateMachineDeploy.Arn

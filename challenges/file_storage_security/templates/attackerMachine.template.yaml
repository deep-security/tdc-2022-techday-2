AWSTemplateFormatVersion: 2010-09-09
Description:
  tdc-2022-techday-1 Cloud One Container Security - Runs state machine to deploy
  nginx to EKS

Metadata:
  # cfn_lint: Disable warning for unused parameters
  cfn-lint:
    config:
      ignore_checks:
        - "W2001"

Parameters:
  QSS3BucketName:
    AllowedPattern: ^[0-9a-zA-Z]+([0-9a-zA-Z-]*[0-9a-zA-Z])*$
    ConstraintDescription:
      Quick Start bucket name can include numbers, lowercase letters, uppercase
      letters, and hyphens (-). It cannot start or end with a hyphen (-).
    Default: none
    Description:
      Update to where you hold the scripts. S3 bucket name for the Tech Day
      assets. Quick Start bucket name can include numbers, lowercase letters,
      uppercase letters, and hyphens (-). It cannot start or end with a hyphen
      (-).
    Type: String
  QSS3KeyPrefix:
    AllowedPattern: ^[0-9a-zA-Z-/._]*$
    ConstraintDescription:
      Quick Start key prefix can include numbers, lowercase letters, uppercase
      letters, hyphens (-), and forward slash (/).
    # REFERENCE (tdc-2022-2): Value in this file ↓
    Default: "latest/challenges/file_storage_security/templates"
    Description:
      Update to where you hold the scripts. S3 bucket name for the Tech Day
      assets. Quick Start key prefix can include numbers, lowercase letters,
      uppercase letters, hyphens (-), and forward slash (/).
    Type: String
  ToolsPrefix:
    AllowedPattern: ^[0-9a-zA-Z-/._]*$
    ConstraintDescription:
      Quick Start key prefix can include numbers, lowercase letters, uppercase
      letters, hyphens (-), and forward slash (/).
    # REFERENCE (tdc-2022-2): Value in this file ↓
    Default: "latest/challenges/file_storage_security/tools"
    Description:
      Update to where you hold the tools for this challenge. Quick Start key
      prefix can include numbers, lowercase letters, uppercase letters, hyphens
      (-), and forward slash (/).
    Type: String
  PlayerPassword:
    Description: The Player's password
    Type: String

Resources:
  # Create iAM Roles
  K8sAdminRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: "/"
      Policies:
        - PolicyName: K8sAdminRole
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - ssm:SendCommand
                  - ssm:PutParameter
                Resource:
                  - !Sub "arn:aws:ssm:*:*:document/${LaunchK8sManifests}"
                  - !Sub "arn:aws:ssm:*:*:document/${PrepareAttackerMachine}"
                  - arn:aws:ssm:*:*:document/AWS-RunShellScript
                  - arn:aws:ssm:*:*:parameter/player/FSS/AttackerLBHostname
              - Effect: Allow
                Action:
                  - ssm:SendCommand
                Resource:
                  - arn:aws:ec2:*:*:instance/*
                Condition:
                  StringLike:
                    ssm:resourceTag/Name:
                      - EKSBastion
              - Effect: Allow
                Action:
                  - ssm:GetCommandInvocation
                  - ssm:ListCommandInvocations
                Resource:
                  - arn:aws:ssm:*:*:*
  StateMachineDeployRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - states.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: "/service-role/"
      Policies:
        - PolicyName: StateMachinePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !GetAtt DeleteAttackerNamespaceLambda.Arn
                  - !GetAtt LaunchK8sManifestsLambda.Arn
                  - !GetAtt PrepareAttackerMachineLambda.Arn
                  - !GetAtt GetAttackerLBHostnameLambda.Arn

# Create SSM Documents
  LaunchK8sManifests: 
    Type: AWS::SSM::Document
    Properties:
      Content:
        schemaVersion: '2.2'
        description: 'Document that launches arbitrary k8s manifest files found in the QSS3Bucket.'
        mainSteps:
        - action: aws:runShellScript
          name: CreateNamespaceIndempotent
          inputs:
            timeoutSeconds: '60'
            runCommand:
              - !Sub | 
                  NAMESPACE=$(echo ${AWS::StackName} | tr '[:upper:]' '[:lower:]' | cut -c -62) \
              - |
                  sudo /usr/local/bin/kubectl delete namespace $NAMESPACE --ignore-not-found=true && \
                  sudo /usr/local/bin/kubectl create namespace $NAMESPACE --dry-run=client -o yaml | sudo /usr/local/bin/kubectl apply -f -
        - action: aws:runShellScript
          name: DeployManifests
          inputs:
            timeoutSeconds: '60'
            runCommand:
              - !Sub | 
                  NAMESPACE=$(echo ${AWS::StackName} | tr '[:upper:]' '[:lower:]' | cut -c -62) \
              - !Sub |
                  mkdir -p /tmp/manifests-$NAMESPACE && \
                  aws s3 cp --recursive s3://${QSS3BucketName}/${QSS3KeyPrefix}k8s/ /tmp/manifests-$NAMESPACE && \
                  sudo /usr/local/bin/kubectl apply --namespace=$NAMESPACE -f /tmp/manifests-$NAMESPACE
      DocumentType: Command
  PrepareAttackerMachine: 
    Type: AWS::SSM::Document
    Properties:
      Content:
        schemaVersion: '2.2'
        description: 'Document that changes the attacker machine to use Player credentials and installs log4shell tools.'
        mainSteps:
        - action: aws:runShellScript
          name: SetupUser
          inputs:
            timeoutSeconds: '120'
            runCommand:
              - !Sub | 
                  NAMESPACE=$(echo ${AWS::StackName} | tr '[:upper:]' '[:lower:]' | cut -c -62) \
                  POD=$(sudo /usr/local/bin/kubectl get pods \
                  --namespace=$NAMESPACE \
                  -l app=attacker-machine \
                  -o jsonpath='{range .items[*]}{.status.containerStatuses[*].ready.true}{.metadata.name}{"\n"}{end}') \
              - !Sub | 
                  sudo /usr/local/bin/kubectl exec --namespace=$NAMESPACE $POD -- /bin/bash -c \
                  "echo 'abc:${PlayerPassword}' | chpasswd && usermod -l Player abc"
        - action: aws:runShellScript
          name: InstallLog4ShellTools
          inputs:
            timeoutSeconds: '120'
            runCommand:
              - !Sub | 
                  NAMESPACE=$(echo ${AWS::StackName} | tr '[:upper:]' '[:lower:]' | cut -c -62) \
                  POD=$(sudo /usr/local/bin/kubectl get pods \
                  --namespace=$NAMESPACE \
                  -l app=attacker-machine \
                  -o jsonpath='{range .items[*]}{.status.containerStatuses[*].ready.true}{.metadata.name}{"\n"}{end}') \
              - !Sub |
                  sudo /usr/local/bin/kubectl exec --namespace=$NAMESPACE $POD -- /bin/bash -c \
                  "sudo apt-get update && \
                  sudo apt-get install -y openjdk-8-jdk unzip curl vim nano net-tools iproute2 && \
                  sudo mkdir -p /config/Desktop/hacker && \
                  curl https://${QSS3BucketName}.s3.amazonaws.com/${ToolsPrefix}JNDIExploit-v1.2.zip --output /tmp/JNDIExploit-v1.2.zip && \
                  sudo unzip -P novirus /tmp/JNDIExploit-v1.2.zip -d /config/Desktop/hacker && \
                  rm /tmp/JNDIExploit-v1.2.zip"
      DocumentType: Command

  # SSM Parameters
  StateMachineDeployArn:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /player/C1CS/StateMachineDeployArn
      Type: String
      Value: !Ref StateMachineDeploy
      Description: ARN for StateMachineDeploy state machine
  AttackerLBHostname:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /player/FSS/AttackerLBHostname
      Type: String
      Value: startingValue
      Description: Load Balancer Hostname for nginx web server

  # Lambda functions
  DeleteAttackerNamespaceLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.8
      Timeout: 20
      Handler: index.lambda_handler
      Role: !GetAtt K8sAdminRole.Arn
      Code:
        ZipFile: !Sub 
        - |
            import boto3


            def lambda_handler(event=None, context=None):
                client = boto3.client("ssm")
                client.send_command(
                    Targets=[{"Key": "tag:Name", "Values": ["EKSBastion"]}],
                    DocumentName="AWS-RunShellScript",
                    Parameters={
                        "commands": [
                            "${commands}"
                    },
                )
        - commands: !Sub | 
            sudo /usr/local/bin/kubectl delete namespace $(echo ${AWS::StackName} | tr '[:upper:]' '[:lower:]') --ignore-not-found=true
  LaunchK8sManifestsLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.8
      Timeout: 20
      Handler: index.lambda_handler
      Role: !GetAtt K8sAdminRole.Arn
      Code:
        ZipFile: !Sub |
          import boto3
          import time
          
          ssm = boto3.client("ssm")
          region = "us-east-1"
          
          
          def lambda_handler(event=None, context=None):
              response = ssm.send_command(
                  Targets=[{"Key": "tag:Name", "Values": ["EKSBastion"]}],
                  DocumentName="${LaunchK8sManifests}",
                  DocumentVersion="$DEFAULT",
                  TimeoutSeconds=123,
                  Comment="string",
              )
              command_id = response["Command"]["CommandId"]
              tries = 0
              while tries < 10:
                  tries = tries + 1
                  try:
                      time.sleep(0.5)  # some delay always required...
                      invocations_list = ssm.list_command_invocations(
                          CommandId=command_id,
                      )["CommandInvocations"]
                      instance_id = sorted(
                          invocations_list, key=lambda d: d["RequestedDateTime"], reverse=True
                      )[0]["InstanceId"]
                      print(instance_id)
                      result = ssm.get_command_invocation(
                          CommandId=command_id,
                          InstanceId=instance_id,
                      )
                      print(result)
                      if result["Status"] == "InProgress":
                          continue
                      if result["Status"] == "TimedOut" or result["Status"] == "Failed":
                          raise Exception("Command failed/timed out.")
                      break
                  except ssm.exceptions.InvocationDoesNotExist:
                      continue
  PrepareAttackerMachineLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.8
      Timeout: 20
      Handler: index.lambda_handler
      Role: !GetAtt K8sAdminRole.Arn
      Code:
        ZipFile: !Sub |
          import boto3
          import time
          
          ssm = boto3.client("ssm")
          region = "us-east-1"
          
          
          def lambda_handler(event=None, context=None):
              response = ssm.send_command(
                  Targets=[{"Key": "tag:Name", "Values": ["EKSBastion"]}],
                  DocumentName="${PrepareAttackerMachine}",
                  DocumentVersion="$DEFAULT",
                  TimeoutSeconds=123,
                  Comment="string",
              )
              command_id = response["Command"]["CommandId"]
              tries = 0
              while tries < 10:
                  tries = tries + 1
                  try:
                      time.sleep(0.5)  # some delay always required...
                      invocations_list = ssm.list_command_invocations(
                          CommandId=command_id,
                      )["CommandInvocations"]
                      instance_id = sorted(
                          invocations_list, key=lambda d: d["RequestedDateTime"], reverse=True
                      )[0]["InstanceId"]
                      print(instance_id)
                      result = ssm.get_command_invocation(
                          CommandId=command_id,
                          InstanceId=instance_id,
                      )
                      print(result)
                      if result["Status"] == "InProgress":
                          continue
                      if result["Status"] == "TimedOut" or result["Status"] == "Failed":
                          raise Exception("Command failed/timed out.")
                      break
                  except ssm.exceptions.InvocationDoesNotExist:
                      continue
  GetAttackerLBHostnameLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.8
      Timeout: 20
      Handler: index.lambda_handler
      Role: !GetAtt K8sAdminRole.Arn
      Code:
        ZipFile: !Sub |
          import boto3
          import time
          
          
          def lambda_handler(event=None, context=None):
              client = boto3.client("ssm")
              response = client.send_command(
                  Targets=[{"Key": "tag:Name", "Values": ["EKSBastion"]}],
                  DocumentName="AWS-RunShellScript",
                  Parameters={
                      "commands": [
                          "sudo /usr/local/bin/kubectl get services --namespace $(echo ${AWS::StackName} | tr '[:upper:]' '[:lower:]') attacker-machine-loadbalancer --output jsonpath='{.status.loadBalancer.ingress[0].hostname}'"
                      ]
                  },
              )
              command_id = response["Command"]["CommandId"]
              tries = 0
              output = "False"
              while tries < 10:
                  tries = tries + 1
                  try:
                      time.sleep(0.5)  # some delay always required...
                      invocations_list = client.list_command_invocations(
                          CommandId=command_id,
                      )["CommandInvocations"]
                      instance_id = sorted(
                          invocations_list, key=lambda d: d["RequestedDateTime"], reverse=True
                      )[0]["InstanceId"]
                      print(instance_id)
                      result = client.get_command_invocation(
                          CommandId=command_id,
                          InstanceId=instance_id,
                      )
                      print(result)
                      if result["Status"] == "InProgress":
                          continue
                      output = result["StandardOutputContent"]
                      break
                  except client.exceptions.InvocationDoesNotExist:
                      continue
          
              client.put_parameter(
                  Name="/player/FSS/AttackerLBHostname",
                  Value=output,
                  Type="String",
                  Overwrite=True,
              )

  # State Machine
  StateMachineDeploy:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: StateMachineDeploy
      DefinitionString: !Sub |
        {
          "StartAt": "LaunchK8sManifestsLambda",
          "States": {
            "LaunchK8sManifestsLambda": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "Payload.$": "$",
                "FunctionName": "${LaunchK8sManifestsLambda.Arn}"
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 6,
                  "BackoffRate": 2
                }
              ],
              "Next": "Wait"
            },
            "Wait": {
              "Type": "Wait",
              "Seconds": 60,
              "Next": "PrepareAttackerMachineLambda"
            },
            "PrepareAttackerMachineLambda": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "Payload.$": "$",
                "FunctionName": "${PrepareAttackerMachineLambda.Arn}"
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 6,
                  "BackoffRate": 2
                }
              ],
              "Next": "GetAttackerLBHostnameLambda"
            },
            "GetAttackerLBHostnameLambda": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "Payload.$": "$",
                "FunctionName": "${GetAttackerLBHostnameLambda.Arn}"
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 6,
                  "BackoffRate": 2
                }
              ],
              "End": true
            }
          },
          "Comment": "Idempotent state machine that deploys an attacker environment to EKS through an EKS bastion.\nNOTE: The EKS bastion(s) in question must have be tagged: \"Name:EKSBastion\"."
        }
      RoleArn: !GetAtt [StateMachineDeployRole, Arn]

Outputs:
  StateMachineDeploy:
    Description: State Machine that deploys the attacker environment in EKS
    Value: !GetAtt StateMachineDeploy.Arn
  GetAttackerLBHostnameLambda:
    Description: GetAttackerLBHostnameLambda Arn
    Value: !GetAtt GetAttackerLBHostnameLambda.Arn
  DeleteAttackerNamespaceLambda:
    Description: DeleteAttackerNamespaceLambda Arn
    Value: !GetAtt DeleteAttackerNamespaceLambda.Arn
